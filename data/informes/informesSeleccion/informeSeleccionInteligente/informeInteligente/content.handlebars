<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Informe Inteligente - {{datosPersonales.nombreCompleto}}</title>
    <style>{{{asset "inteligente-styles.css"}}}</style>
    
    <!-- FASE 3 CSS M√≠nimo - Solo elementos cr√≠ticos -->
    <style id="fase3-base-css">
        /* üß† FASE 3 - CSS M√≠nimo que NO interfiere con optimizaci√≥n din√°mica */
        
        /* SOLO prevenir cortes dentro de elementos individuales cr√≠ticos */
        .bloque-editorial, .experiencia-item, .lista-item, .competency-card {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
        }
        
        /* Reducir espaciado para mejor aprovechamiento */
        .module-header {
            margin-bottom: 8px !important;
        }
        
        .module-content {
            margin-top: 0px !important;
        }
        
        .section-title {
            margin-top: 8px !important;
            margin-bottom: 6px !important;
        }
        
        /* IMPORTANTE: NO definir reglas para .module, .section, .module-title aqu√≠ */
        /* Dejar que el CSS din√°mico de optimizaci√≥n de espacio controle el flujo */
    </style>
</head>
<body class="report {{#if __layout.isLandscape}}landscape{{/if}}" data-breadcrumb="Informe de Selecci√≥n">

<!-- M√ìDULO 0: PORTADA INTRODUCTORIA -->
<section class="module cover-page" data-breadcrumb="Portada">
    <!-- HEADER PRINCIPAL - PORTADA INTRODUCTORIA -->
    <header class="main-header" data-breadcrumb="Portada Introductoria">
        <div class="header-grid">
            <div class="brand-section">
                <img class="logo" src="{{asset '/assets/logos/001LogotipoGrupompleo.png' 'dataURI'}}"
                     alt="Grupo Empleo"/>
                <div class="brand-text">
                    <h1 class="brand-name">GRUPOMPLEO</h1>
                    <p class="brand-tagline">Recursos Humanos ¬∑ Sector Industrial</p>
                </div>
            </div>
            <div class="report-meta">
                <span class="report-type">{{tipoInforme}}</span>
                <span class="report-date">{{formatDate fechaEmision}}</span>
                <span class="report-id">#{{idInforme}}</span>
            </div>
        </div>
    </header>

    <!-- BRANDING Y GR√ÅFICOS INDUSTRIALES -->
    <!-- 
    <div class="cover-branding">
      <div class="brand">GRUPOMPLEO</div>
      <div class="cover__subtitle">Transparencia ‚Ä¢ Legalidad ‚Ä¢ Cercan√≠a ‚Ä¢ Industria</div>
    </div> -->

    <div class="cover-image-container">
        <img class="grafico" src="{{asset '/assets/graphics/GeoColor.png' 'dataURI'}}" alt="Grupo Empleo"/>
    </div>

    <!-- DATOS ADICIONALES DEL INFORME -->
    <div class="cover-metadata">
        <div class="metadata-grid">
            <div class="metadata-item">
                <span class="metadata-label">ID Publicaci√≥n</span>
                <span class="metadata-value">{{idInformeCvPublicacion}}</span>
            </div>
            <div class="metadata-item">
                <span class="metadata-label">ID Pedido</span>
                <span class="metadata-value">{{idPedidoMaster}}</span>
            </div>
            <div class="metadata-item">
                <span class="metadata-label">Fecha Publicaci√≥n</span>
                <span class="metadata-value">{{formatDate fechaPublicacion}}</span>
            </div>
            <div class="metadata-item">
                <span class="metadata-label">Estado</span>
                <span class="metadata-value">{{#if publicado}}Publicado{{else}}En proceso{{/if}}</span>
            </div>
            <div class="metadata-item">
                <span class="metadata-label">Tipo Informe</span>
                <span class="metadata-value">{{idTipoInforme}}</span>
            </div>
            <div class="metadata-item">
                <span class="metadata-label">Usuario Creador</span>
                <span class="metadata-value">{{idUsuarioCreador}}</span>
            </div>
        </div>
    </div>


</section>

<!-- ITERACI√ìN DE M√ìDULOS DIN√ÅMICOS -->
{{#each modulos}}
    <section class="module module-{{@index}}" data-breadcrumb="{{this.titulo}}">

        {{!-- HEADER DEL M√ìDULO PRIMERO --}}
        <header class="module-header">
            <h2 class="module-title">{{this.titulo}}</h2>
            {{#if this.subtitulo}}
                <p class="module-subtitle">{{this.subtitulo}}</p>
            {{/if}}
        </header>

        {{!-- M√ìDULO 0: Presentaci√≥n - Incluye datos b√°sicos del candidato y datos destacados --}}
        {{#ifEquals @index 0}}
            <!-- INFORMACI√ìN DEL CANDIDATO - DATOS B√ÅSICOS -->
            <section class="candidate-header" data-breadcrumb="Datos del Candidato">
                <div class="candidate-grid">
                    <div class="candidate-photo-wrapper">
                        {{#if ../datosPersonales.foto}}
                            <img
                                    class="candidate-photo"
                                    src="{{asset '/assets/profiles/AA.jpg' 'dataURI'}}"
                                    alt="Foto"
                            />
                        {{/if}}
                    </div>
                    <div class="candidate-info">
                        <h2 class="candidate-name">{{../datosPersonales.nombreCompleto}}</h2>
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">Edad</span>
                                <span class="info-value">{{../datosPersonales.edad}} a√±os</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Ubicaci√≥n</span>
                                <span class="info-value">{{../datosPersonales.municipio}}
                                    , {{../datosPersonales.pais}}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Email</span>
                                <span class="info-value">{{../datosPersonales.email}}</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Tel√©fono</span>
                                <span class="info-value">{{../datosPersonales.telefonoMovil}}</span>
                            </div>
                        </div>
                    </div>
                    {{#if ../informe.puntuacion}}
                        <div class="candidate-score">
                            <div class="score-circle">
                                <span class="score-value">{{../informe.puntuacion}}</span>
                                <span class="score-max">/10</span>
                            </div>
                            <span class="score-label">Puntuaci√≥n Global</span>
                        </div>
                    {{/if}}
                </div>
            </section>
        {{/ifEquals}}

        <div class="module-content">
            {{#each this.secciones}}
                <div class="section" data-breadcrumb="{{../titulo}} ‚Ä∫ {{this.nombre}}">
                    <h3 class="section-title">{{this.nombre}}</h3>

                    {{#if this.tipo}}
                    {{!-- TIPO datos-basicos eliminado: ya se muestra en header del candidato --}}

                    {{!-- TIPO: texto-editorial (bloques editoriales con subt√≠tulos) --}}
                        {{#ifEquals this.tipo "texto-editorial"}}
                            <div class="texto-editorial">
                                {{#each this.items}}
                                    <div class="bloque-editorial no-break">
                                        <h4 class="editorial-subtitulo">{{this.subtitulo}}</h4>
                                        <div class="editorial-contenido">
                                            {{#each (splitParagraphs this.contenido)}}
                                                <p class="paragraph">{{this}}</p>
                                            {{/each}}
                                        </div>
                                    </div>
                                {{/each}}
                            </div>
                        {{/ifEquals}}

                        {{!-- TIPO: texto (p√°rrafos simples) --}}
                        {{#ifEquals this.tipo "texto"}}
                            <div class="text-content">
                                {{#each (splitParagraphs this.contenido)}}
                                    <p class="paragraph no-break">{{this}}</p>
                                {{/each}}
                            </div>
                        {{/ifEquals}}

                        {{!-- TIPO: lista (experiencia, formaci√≥n, referencias, etc.) --}}
                        {{#ifEquals this.tipo "lista"}}
                            <div class="lista-content">
                                {{#each this.items}}
                                    <div class="lista-item no-break"
                                         data-breadcrumb="{{../../titulo}} ‚Ä∫ {{../nombre}} ‚Ä∫ Item {{@index}}">

                                        {{!-- Lista de experiencia --}}
                                        {{#if this.puesto}}
                                            <div class="experiencia-item item-with-border">
                                                <h4 class="puesto">{{this.puesto}}</h4>
                                                <div class="empresa-rango">
                                                    <span class="empresa">{{this.empresa}}</span>
                                                    <span class="rango-anos">{{this.rangoAnos}}</span>
                                                </div>
                                                {{#if this.funcion}}
                                                    <p class="funcion">{{this.funcion}}</p>
                                                {{/if}}
                                            </div>
                                        {{/if}}

                                        {{!-- Lista de formaci√≥n --}}
                                        {{#if this.nombreTitulacion}}
                                            <div class="formacion-item item-with-border">
                                                <h4 class="titulacion">{{this.nombreTitulacion}}</h4>
                                                <div class="centro-ano">
                                                    <span class="centro">{{this.centro}}</span>
                                                    <span class="ano">{{this.ano}}</span>
                                                </div>
                                                <span class="titulado-status">{{this.titulado}}</span>
                                            </div>
                                        {{/if}}

                                        {{!-- Lista de referencias - Buscar por empresa sin campo puesto --}}
                                        {{#if this.contacto}}
                                            <div class="referencia-item item-with-border">
                                                <h4 class="ref-empresa">{{this.empresa}}</h4>
                                                <p class="ref-funcion">{{this.funcion}}</p>
                                                <p class="ref-contacto">{{this.contacto}}</p>
                                            </div>
                                        {{/if}}

                                        {{!-- Lista de idiomas --}}
                                        {{#if this.idioma}}
                                            <div class="idioma-item item-with-border">
                                                <span class="idioma">{{this.idioma}}</span>
                                                <span class="nivel">{{this.nivel}}</span>
                                            </div>
                                        {{/if}}

                                        {{!-- Lista de inform√°tica --}}
                                        {{#if this.aplicacion}}
                                            <div class="software-item item-with-border">
                                                <span class="aplicacion">{{this.aplicacion}}</span>
                                                <span class="nivel">{{this.nivel}}</span>
                                            </div>
                                        {{/if}}

                                        {{!-- Lista de acreditaciones --}}
                                        {{#if this.tipo}}
                                            <div class="acreditacion-item item-with-border">
                                                <span class="acred-tipo">{{this.tipo}}</span>
                                                <span class="acred-ano">{{this.ano}}</span>
                                                {{#if this.descripcion}}
                                                    <p class="acred-desc">{{this.descripcion}}</p>
                                                {{/if}}
                                            </div>
                                        {{/if}}

                                        {{!-- Lista de adjuntos --}}
                                        {{#if this.ruta}}
                                            <div class="adjunto-item item-with-border">
                                                <span class="adj-tipo">{{this.tipo}}</span>
                                                <span class="adj-ruta">{{this.ruta}}</span>
                                                <span class="adj-horas">{{this.horas}}</span>
                                            </div>
                                        {{/if}}

                                        {{!-- Fallback para listas gen√©ricas --}}
                                        {{#unless this.puesto}}{{#unless this.nombreTitulacion}}{{#unless
                                                this.empresa}}{{#unless this.idioma}}{{#unless
                                                this.aplicacion}}{{#unless this.tipo}}{{#unless this.ruta}}
                                            <div class="item-generico">
                                                {{#if this.titulo}}<strong>{{this.titulo}}</strong>{{/if}}
                                                {{#if this.descripcion}}
                                                    <span class="item-desc">{{this.descripcion}}</span>{{/if}}
                                                {{#if this.fecha}}
                                                    <span class="item-date">{{formatDate this.fecha}}</span>{{/if}}
                                            </div>
                                        {{/unless}}{{/unless}}{{/unless}}{{/unless}}{{/unless}}{{/unless}}{{/unless}}
                                    </div>
                                {{/each}}
                            </div>
                        {{/ifEquals}}

                        {{!-- TIPO: cards (competencias) --}}
                        {{#ifEquals this.tipo "cards"}}
                            <div class="cards-grid">
                                {{#each this.items}}
                                    <div class="card no-break"
                                         data-breadcrumb="{{../../titulo}} ‚Ä∫ {{../nombre}} ‚Ä∫ {{this.competencia}}">
                                        <h4 class="card-title">{{this.competencia}}</h4>
                                        {{#if this.puntuacion}}
                                            <div class="card-score">{{this.puntuacion}}/10</div>
                                        {{/if}}
                                        <p class="card-content">{{this.observaciones}}</p>
                                    </div>
                                {{/each}}
                            </div>
                        {{/ifEquals}}

                        {{!-- TIPO: puntuacion-final (bloque num√©rico) --}}
                        {{#ifEquals this.tipo "puntuacion-final"}}
                            <div class="puntuacion-final no-break">
                                <div class="score-display">
                                    <span class="score-value">{{this.puntuacion}}</span>
                                    <span class="score-separator">/</span>
                                    <span class="score-max">{{this.maxPuntuacion}}</span>
                                </div>
                                <p class="score-label">Puntuaci√≥n Global</p>
                            </div>
                        {{/ifEquals}}

                        {{!-- TIPO: tabla (fallback para tablas gen√©ricas) --}}
                        {{#ifEquals this.tipo "tabla"}}
                            <div class="table-wrapper">
                                <table class="data-table">
                                    <thead>
                                    <tr>
                                        {{#each this.columnas}}
                                            <th>{{this}}</th>
                                        {{/each}}
                                    </tr>
                                    </thead>
                                    <tbody>
                                    {{#each this.filas}}
                                        <tr class="no-break">
                                            {{#each this}}
                                                <td>{{this}}</td>
                                            {{/each}}
                                        </tr>
                                    {{/each}}
                                    </tbody>
                                </table>
                            </div>
                        {{/ifEquals}}
                    {{/if}}
                </div>
            {{/each}}
        </div>
    </section>
{{/each}}

<!-- DEBUG: Verificar si los m√≥dulos se est√°n creando -->
<div style="background: #f0f0f0; padding: 10px; margin: 10px 0; font-family: monospace; font-size: 10px;">
    <strong>DEBUG - Total m√≥dulos:</strong> {{modulos.length}}<br>
    {{#if modulos}}
        <strong>M√≥dulos encontrados:</strong><br>
        {{#each modulos}}
            - {{@index}}: {{this.titulo}} ({{this.secciones.length}} secciones)<br>
        {{/each}}
    {{else}}
        <strong style="color: red;">‚ö†Ô∏è NO HAY M√ìDULOS - beforeRender no se ejecut√≥</strong>
    {{/if}}
</div>


<!-- FOOTER -->
<footer class="page-footer">
    <div class="footer-content">
        <span class="confidential">CONFIDENCIAL - Uso exclusivo del cliente</span>
        <span class="page-info">
        <span class="page-number"></span> / <span class="total-pages"></span>
      </span>
    </div>
</footer>

{{#if __layout.fase2.diagnosticsEnabled}}
<!-- ================================================================================ -->
<!-- üìä PANEL DE DIAGN√ìSTICO FASE 2 - MOTOR DE C√ÅLCULO AVANZADO -->
<!-- ================================================================================ -->
<section class="diagnostics-panel" style="
    margin-top: 40px; 
    padding: 20px; 
    background: #f8f9fa; 
    border: 1px solid #dee2e6; 
    font-family: monospace; 
    font-size: 11px;
    page-break-before: always;
">
    <h3 style="color: #495057; margin: 0 0 16px 0; font-size: 14px;">
        üöÄ Diagn√≥stico FASE 2 - Motor de C√°lculo Avanzado
    </h3>
    
    <!-- Informaci√≥n del beforeRender -->
    <div style="margin-bottom: 16px;">
        <strong>üìã Procesamiento beforeRender:</strong><br>
        ‚Ä¢ Timestamp: {{__layout.fase2.timestamp}}<br>
        ‚Ä¢ Estado: {{#if __layout.fase2.enabled}}‚úÖ Habilitado{{else}}‚ùå Error: {{__layout.fase2.error}}{{/if}}<br>
        ‚Ä¢ M√≥dulos procesados: {{__layout.moduleCount}}<br>
        ‚Ä¢ Orientaci√≥n: {{#if __layout.isLandscape}}Landscape{{else}}Portrait{{/if}}<br>
        ‚Ä¢ Caracteres totales: {{__layout.totalChars}}<br>
        ‚Ä¢ Elementos totales: {{__layout.totalItems}}<br>
    </div>
    
    <!-- Informaci√≥n de scripts FASE 2 -->
    <div style="margin-bottom: 16px;">
        <strong>üîß Scripts FASE 2 (se inicializar√°n en navegador):</strong><br>
        ‚Ä¢ PhantomRenderer: Pre-c√°lculo de medidas<br>
        ‚Ä¢ CalculationEngine: Motor coordinador<br>
        ‚Ä¢ MeasurementDatabase: Base de datos de medidas<br>
        ‚Ä¢ MeasurementCache: Cache inteligente con TTL<br>
        ‚Ä¢ MeasurementService: Servicio mejorado (FASE 1 + FASE 2)<br>
    </div>
    
    <!-- Placeholder para resultados del navegador -->
    <div id="diagnostics-browser-results" style="margin-bottom: 16px;">
        <strong>‚è±Ô∏è Resultados FASE 2 (se llenar√°n din√°micamente):</strong><br>
        <span id="phantom-status">‚Ä¢ PhantomRenderer: Pendiente...</span><br>
        <span id="calculation-status">‚Ä¢ CalculationEngine: Pendiente...</span><br>
        <span id="cache-status">‚Ä¢ Cache: Pendiente...</span><br>
    </div>
    
    <!-- Resultados FASE 3 -->
    <div id="diagnostics-fase3-results" style="margin-bottom: 16px;">
        <strong>üéØ Resultados FASE 3 - Distribuci√≥n Inteligente:</strong><br>
        <span id="breakpoint-status">‚Ä¢ OptimalBreakpoint: Pendiente...</span><br>
        <span id="orphan-status">‚Ä¢ OrphanPrevention: Pendiente...</span><br>
        <span id="continuity-status">‚Ä¢ ContinuityRules: Pendiente...</span><br>
        <span id="html-application-status">‚Ä¢ HTML Application: Pendiente...</span><br>
        <span id="space-optimization-status">‚Ä¢ Space Optimization: Pendiente...</span><br>
        <span id="optimization-status">‚Ä¢ Optimizaci√≥n: Pendiente...</span><br>
    </div>
    
    <!-- Debug de m√≥dulos -->
    <div style="margin-bottom: 16px;">
        <strong>üì¶ M√≥dulos detectados:</strong><br>
        {{#each modulos}}
        ‚Ä¢ M√≥dulo {{@index}}: {{titulo}} ({{moduleType}}) - {{secciones.length}} secciones<br>
        {{/each}}
    </div>
    
    <div style="font-size: 10px; color: #6c757d; margin-top: 12px;">
        Generado por informeSeleccionInteligente FASE 2 - Motor de C√°lculo Avanzado
    </div>
</section>
{{/if}}

<!-- ================================================================================ -->
<!-- üöÄ FASE 2 SIMPLIFICADA - MOTOR DE C√ÅLCULO INTEGRADO -->
<!-- ================================================================================ -->

<script>
// FASE 2 - Versi√≥n simplificada integrada
(function() {
    'use strict';
    
    /**
     * MEASUREMENT CACHE SIMPLIFICADO - FASE 2
     */
    class SimpleMeasurementCache {
        constructor() {
            this.cache = new Map();
            this.maxSize = 100;
            this.ttl = 300000; // 5 minutos
            this.stats = { hits: 0, misses: 0 };
        }
        
        set(key, value) {
            if (this.cache.size >= this.maxSize) {
                const firstKey = this.cache.keys().next().value;
                this.cache.delete(firstKey);
            }
            
            this.cache.set(key, {
                value,
                timestamp: Date.now()
            });
        }
        
        get(key) {
            const item = this.cache.get(key);
            if (!item) {
                this.stats.misses++;
                return null;
            }
            
            if (Date.now() - item.timestamp > this.ttl) {
                this.cache.delete(key);
                this.stats.misses++;
                return null;
            }
            
            this.stats.hits++;
            return item.value;
        }
        
        getStats() {
            return { ...this.stats, size: this.cache.size };
        }
    }
    
    /**
     * MEASUREMENT DATABASE SIMPLIFICADO - FASE 2
     */
    class SimpleMeasurementDatabase {
        constructor() {
            this.standards = {
                'h1': { height: 40, confidence: 0.9 },
                'h2': { height: 32, confidence: 0.9 },
                'h3': { height: 24, confidence: 0.9 },
                'paragraph': { height: 20, confidence: 0.8 },
                'module': { height: 60, confidence: 0.7 },
                'section': { height: 40, confidence: 0.8 },
                'competency-card': { height: 50, confidence: 0.9 },
                'experience-item': { height: 80, confidence: 0.8 },
                'generic': { height: 30, confidence: 0.6 }
            };
        }
        
        getStandardMeasurement(elementType) {
            return this.standards[elementType] || this.standards['generic'];
        }
        
        getConfidence(elementType) {
            const standard = this.getStandardMeasurement(elementType);
            return standard ? standard.confidence : 0.5;
        }
    }
    
    /**
     * PHANTOM RENDERER SIMPLIFICADO - FASE 2
     */
    class SimplePhantomRenderer {
        constructor() {
            this.measurements = [];
        }
        
        async measureElements() {
            console.log('üîç [FASE 2] Iniciando medici√≥n simplificada de elementos...');
            
            const elements = document.querySelectorAll('.module, .section, h1, h2, h3, p');
            const measurements = [];
            
            elements.forEach((element, index) => {
                const rect = element.getBoundingClientRect();
                const measurement = {
                    index,
                    element: element.tagName.toLowerCase(),
                    className: element.className,
                    height: rect.height,
                    width: rect.width,
                    text: element.textContent.substring(0, 50),
                    complexity: this.calculateComplexity(element)
                };
                measurements.push(measurement);
            });
            
            this.measurements = measurements;
            console.log(`üìè [FASE 2] Medidos ${measurements.length} elementos`);
            return measurements;
        }
        
        calculateComplexity(element) {
            let complexity = 1;
            complexity += element.children.length * 0.5;
            complexity += Math.min(element.textContent.length / 100, 2);
            return Math.min(complexity, 5);
        }
        
        calculateDistribution() {
            const pageHeight = 1100; // Aproximado A4
            let currentHeight = 0;
            let pageCount = 1;
            let elementsPerPage = [];
            let currentPageElements = [];
            
            this.measurements.forEach((measurement) => {
                if (currentHeight + measurement.height > pageHeight) {
                    elementsPerPage.push(currentPageElements);
                    currentPageElements = [measurement];
                    currentHeight = measurement.height;
                    pageCount++;
                } else {
                    currentPageElements.push(measurement);
                    currentHeight += measurement.height;
                }
            });
            
            if (currentPageElements.length > 0) {
                elementsPerPage.push(currentPageElements);
            }
            
            return { pageCount, elementsPerPage, totalHeight: currentHeight };
        }
    }
    
    // Exponer globalmente
    window.SimpleMeasurementCache = SimpleMeasurementCache;
    window.SimpleMeasurementDatabase = SimpleMeasurementDatabase;
    window.SimplePhantomRenderer = SimplePhantomRenderer;
    
})();

// ================================================================================
// üéØ FASE 3 - DISTRIBUCI√ìN INTELIGENTE
// ================================================================================
(function() {
    'use strict';
    
    /**
     * OPTIMAL BREAKPOINT CALCULATOR - FASE 3
     * Algoritmo de costos para calcular puntos de corte √≥ptimos
     */
    class OptimalBreakpointCalculator {
        constructor(pageHeight = 1122) { // A4 menos m√°rgenes
            this.pageHeight = pageHeight;
            
            // Costos de ruptura por tipo de elemento
            this.breakCosts = {
                // Elementos que prefieren NO romperse
                'module-header': 100,    // Header de m√≥dulo al final de p√°gina = muy malo
                'section-header': 80,    // Header de secci√≥n al final = malo
                'competency-card': 60,   // Cards partidas = moderado
                'experience-item': 40,   // Items de experiencia partidos = leve
                
                // Elementos que pueden romperse con poco costo
                'paragraph': 10,         // P√°rrafos pueden partirse
                'list-item': 20,         // Items de lista pueden partirse
                
                // Puntos de corte naturales (bajo costo)
                'module-end': 5,         // Final de m√≥dulo = natural
                'section-end': 8,        // Final de secci√≥n = natural
                'paragraph-end': 2       // Final de p√°rrafo = muy natural
            };
            
            // Umbrales para prevenci√≥n de hu√©rfanos
            this.orphanThresholds = {
                'module-header': 0.3,    // 30% m√≠nimo de p√°gina tras header
                'section-header': 0.25,  // 25% m√≠nimo de p√°gina tras header
                'competency-card': 0.15  // 15% m√≠nimo para cards
            };
        }
        
        /**
         * Calcula puntos de corte √≥ptimos basado en mediciones reales
         */
        calculateOptimalBreaks(measurements, totalHeight) {
            console.log('üéØ [FASE 3] Calculando puntos de corte √≥ptimos...');
            console.log(`üìä [FASE 3] Input: ${measurements.length} elementos, altura total: ${totalHeight}px`);
            
            const pages = [];
            let currentPage = {
                elements: [],
                currentHeight: 0,
                pageNumber: 1,
                costScore: 0
            };
            
            let breakDecisions = [];
            
            for (let i = 0; i < measurements.length; i++) {
                const element = measurements[i];
                const nextElement = measurements[i + 1];
                
                // Validar que el elemento tenga las propiedades requeridas
                if (!element || typeof element.height !== 'number') {
                    console.warn(`‚ö†Ô∏è [FASE 3] Elemento inv√°lido en √≠ndice ${i}:`, element);
                    continue;
                }
                
                // Verificar si el elemento cabe en la p√°gina actual
                if (currentPage.currentHeight + element.height <= this.pageHeight) {
                    // Cabe, agregarlo
                    currentPage.elements.push(element);
                    currentPage.currentHeight += element.height;
                } else {
                    // No cabe, evaluar punto de corte
                    const breakCost = this._calculateBreakCost(element, nextElement, currentPage);
                    const elementType = this._detectElementType(element);
                    
                    // Crear identificador del elemento
                    const elementIdentifier = element.element ? 
                        `${element.element}.${element.className || 'no-class'}` : 
                        `element-${element.index}`;
                    
                    // Log de decisi√≥n de corte
                    breakDecisions.push({
                        beforeElement: elementIdentifier,
                        elementType: elementType,
                        breakCost: breakCost,
                        pageHeight: currentPage.currentHeight,
                        pageNumber: currentPage.pageNumber
                    });
                    
                    console.log(`‚úÇÔ∏è [FASE 3] Corte en p√°gina ${currentPage.pageNumber}: antes de "${elementIdentifier}" (${elementType}) - Costo: ${breakCost}`);
                    
                    // Si el costo es muy alto, intentar ajustar
                    if (breakCost > 60 && this._canAdjustPreviousElements(currentPage)) {
                        console.log(`üîÑ [FASE 3] Costo alto (${breakCost}), intentando ajustar...`);
                        this._adjustForOptimalBreak(currentPage);
                    }
                    
                    // Finalizar p√°gina actual
                    currentPage.costScore += breakCost;
                    pages.push({ ...currentPage });
                    
                    // Iniciar nueva p√°gina
                    currentPage = {
                        elements: [element],
                        currentHeight: element.height,
                        pageNumber: pages.length + 1,
                        costScore: 0
                    };
                }
            }
            
            // Agregar √∫ltima p√°gina
            if (currentPage.elements.length > 0) {
                pages.push(currentPage);
            }
            
            const totalCost = pages.reduce((sum, page) => sum + page.costScore, 0);
            const avgCostPerPage = totalCost / pages.length;
            
            console.log(`üéØ [FASE 3] Distribuci√≥n calculada: ${pages.length} p√°ginas, costo promedio: ${avgCostPerPage.toFixed(1)}`);
            
            // Log detallado de todas las decisiones
            console.log('üìã [FASE 3] Resumen de decisiones de corte:');
            breakDecisions.forEach((decision, index) => {
                const costLevel = decision.breakCost > 60 ? 'üî¥' : decision.breakCost > 30 ? 'üü°' : 'üü¢';
                console.log(`  ${costLevel} Corte ${index + 1}: ${decision.beforeElement} (${decision.elementType}) - Costo: ${decision.breakCost}`);
            });
            
            // Log de distribuci√≥n por p√°gina
            console.log('üìÑ [FASE 3] Distribuci√≥n por p√°ginas:');
            pages.forEach((page, index) => {
                console.log(`  P√°gina ${page.pageNumber}: ${page.elements.length} elementos, ${page.currentHeight}px, costo: ${page.costScore}`);
            });
            
            return {
                pages,
                totalCost,
                avgCostPerPage,
                pageCount: pages.length,
                optimization: this._getOptimizationSummary(pages),
                breakDecisions: breakDecisions
            };
        }
        
        /**
         * Calcula el costo de romper en un punto espec√≠fico
         */
        _calculateBreakCost(element, nextElement, currentPage) {
            let cost = 0;
            
            // Detectar tipo de elemento para aplicar costo base
            const elementType = this._detectElementType(element);
            const baseCost = this.breakCosts[elementType] || 30;
            cost += baseCost;
            
            // Penalizar headers hu√©rfanos
            if (elementType.includes('header')) {
                const remainingHeight = this.pageHeight - currentPage.currentHeight;
                const orphanThreshold = this.orphanThresholds[elementType] * this.pageHeight;
                
                if (nextElement && remainingHeight < orphanThreshold) {
                    cost += 50; // Penalizaci√≥n por header hu√©rfano
                    console.log(`‚ö†Ô∏è [FASE 3] Header hu√©rfano detectado: ${element.selector}`);
                }
            }
            
            // Bonus por puntos de corte naturales
            if (this._isNaturalBreakPoint(element, currentPage)) {
                cost -= 15;
            }
            
            return Math.max(0, cost);
        }
        
        /**
         * Detecta el tipo de elemento para aplicar reglas espec√≠ficas
         */
        _detectElementType(element) {
            if (!element) {
                console.warn('‚ö†Ô∏è [FASE 3] Elemento inv√°lido:', element);
                return 'generic';
            }
            
            // Crear identificador usando elemento y className
            const elementType = element.element ? element.element.toLowerCase() : '';
            const className = element.className ? element.className.toLowerCase() : '';
            const identifier = `${elementType} ${className}`;
            
            // Detectar headers de m√≥dulo
            if (elementType === 'h1' || elementType === 'h2' || className.includes('module-title')) {
                return 'module-header';
            }
            
            // Detectar headers de secci√≥n
            if (elementType === 'h3' || className.includes('section-title')) {
                return 'section-header';
            }
            
            // Detectar cards de competencias
            if (className.includes('competency') || className.includes('card') || className.includes('card-content')) {
                return 'competency-card';
            }
            
            // Detectar elementos de experiencia
            if (className.includes('experience') || className.includes('work') || className.includes('empresa')) {
                return 'experience-item';
            }
            
            // Detectar p√°rrafos
            if (elementType === 'p' || className.includes('paragraph')) {
                return 'paragraph';
            }
            
            // Detectar items de lista
            if (elementType === 'li' || className.includes('item') || className.includes('list')) {
                return 'list-item';
            }
            
            // Detectar m√≥dulos completos
            if (className.includes('module')) {
                return 'module';
            }
            
            return 'generic';
        }
        
        /**
         * Determina si es un punto de corte natural
         */
        _isNaturalBreakPoint(element, currentPage) {
            if (!element || !currentPage || !currentPage.elements) {
                return false;
            }
            
            // Final de m√≥dulo o secci√≥n
            const className = element.className ? element.className.toLowerCase() : '';
            if (className.includes('module') && currentPage.elements.length > 0) {
                return true;
            }
            
            // Despu√©s de un conjunto de elementos similares
            const lastElements = currentPage.elements.slice(-3);
            if (lastElements.length === 0) return false;
            
            try {
                const allSameType = lastElements.every(el => 
                    this._detectElementType(el) === this._detectElementType(element)
                );
                
                return allSameType && lastElements.length >= 3;
            } catch (error) {
                console.warn('‚ö†Ô∏è [FASE 3] Error en isNaturalBreakPoint:', error);
                return false;
            }
        }
        
        /**
         * Verifica si se pueden ajustar elementos previos para mejor distribuci√≥n
         */
        _canAdjustPreviousElements(currentPage) {
            return currentPage.elements.length > 1 && currentPage.currentHeight > this.pageHeight * 0.7;
        }
        
        /**
         * Ajusta elementos para lograr un mejor punto de corte
         */
        _adjustForOptimalBreak(currentPage) {
            // Mover √∫ltimo elemento a pr√≥xima p√°gina si mejora el costo
            const lastElement = currentPage.elements.pop();
            currentPage.currentHeight -= lastElement.height;
            
            console.log(`üîÑ [FASE 3] Ajuste realizado: moviendo ${lastElement.selector} a siguiente p√°gina`);
        }
        
        /**
         * Genera resumen de optimizaci√≥n
         */
        _getOptimizationSummary(pages) {
            let orphanHeaders = 0;
            let naturalBreaks = 0;
            let forcedBreaks = 0;
            
            pages.forEach(page => {
                if (page.costScore > 60) forcedBreaks++;
                else if (page.costScore < 20) naturalBreaks++;
                
                // Contar headers potencialmente hu√©rfanos
                const lastElement = page.elements[page.elements.length - 1];
                if (lastElement && this._detectElementType(lastElement).includes('header')) {
                    orphanHeaders++;
                }
            });
            
            return {
                orphanHeaders,
                naturalBreaks,
                forcedBreaks,
                efficiency: ((naturalBreaks / pages.length) * 100).toFixed(1)
            };
        }
    }
    
    /**
     * ORPHAN PREVENTION SYSTEM - FASE 3
     * Previene headers hu√©rfanos y mejora la distribuci√≥n
     */
    class OrphanPreventionSystem {
        constructor(pageHeight = 1122) {
            this.pageHeight = pageHeight;
            
            // Configuraci√≥n de prevenci√≥n de hu√©rfanos
            this.orphanRules = {
                'module-header': {
                    minContentAfter: 0.25,    // 25% m√≠nimo de p√°gina tras header
                    penaltyMultiplier: 2.0,   // Penalizaci√≥n por hu√©rfano
                    forceBreakBefore: true    // Forzar salto antes si es hu√©rfano
                },
                'section-header': {
                    minContentAfter: 0.20,    // 20% m√≠nimo
                    penaltyMultiplier: 1.5,
                    forceBreakBefore: true
                },
                'competency-card': {
                    minContentAfter: 0.10,    // 10% m√≠nimo
                    penaltyMultiplier: 1.2,
                    forceBreakBefore: false   // No forzar, solo penalizar
                }
            };
        }
        
        /**
         * Aplica prevenci√≥n de hu√©rfanos a una distribuci√≥n existente
         */
        preventOrphans(distribution, measurements) {
            console.log('üõ°Ô∏è [FASE 3] Aplicando prevenci√≥n de hu√©rfanos...');
            
            let adjustedPages = [];
            let orphansDetected = 0;
            let orphansFixed = 0;
            
            for (let i = 0; i < distribution.pages.length; i++) {
                const page = distribution.pages[i];
                const nextPage = distribution.pages[i + 1];
                
                // Buscar headers potencialmente hu√©rfanos al final de la p√°gina
                const potentialOrphans = this._findPotentialOrphans(page);
                
                if (potentialOrphans.length > 0) {
                    orphansDetected += potentialOrphans.length;
                    
                    // Intentar ajustar la p√°gina para evitar hu√©rfanos
                    const adjustedPage = this._adjustPageToPreventOrphans(page, nextPage, potentialOrphans);
                    
                    if (adjustedPage.orphansFixed > 0) {
                        orphansFixed += adjustedPage.orphansFixed;
                        console.log(`üîß [FASE 3] P√°gina ${page.pageNumber}: ${adjustedPage.orphansFixed} hu√©rfanos corregidos`);
                    }
                    
                    adjustedPages.push(adjustedPage.page);
                } else {
                    adjustedPages.push(page);
                }
            }
            
            // Recalcular distribuci√≥n despu√©s de ajustes
            const optimizedDistribution = this._recalculateDistribution(adjustedPages, measurements);
            
            console.log(`üõ°Ô∏è [FASE 3] Prevenci√≥n completada: ${orphansDetected} detectados, ${orphansFixed} corregidos`);
            
            return {
                pages: optimizedDistribution.pages,
                orphansDetected,
                orphansFixed,
                improvementScore: orphansFixed / Math.max(orphansDetected, 1),
                totalCost: optimizedDistribution.totalCost
            };
        }
        
        /**
         * Encuentra headers potencialmente hu√©rfanos en una p√°gina
         */
        _findPotentialOrphans(page) {
            const orphans = [];
            const elements = page.elements || [];
            
            // Examinar los √∫ltimos elementos de la p√°gina
            for (let i = Math.max(0, elements.length - 3); i < elements.length; i++) {
                const element = elements[i];
                const elementType = this._detectElementType(element);
                
                if (this.orphanRules[elementType]) {
                    const rule = this.orphanRules[elementType];
                    const remainingHeight = this.pageHeight - page.currentHeight;
                    const minRequiredHeight = this.pageHeight * rule.minContentAfter;
                    
                    if (remainingHeight < minRequiredHeight) {
                        orphans.push({
                            element,
                            elementIndex: i,
                            elementType,
                            rule,
                            deficit: minRequiredHeight - remainingHeight
                        });
                        
                        console.log(`üëª [FASE 3] Hu√©rfano detectado: ${elementType} en p√°gina ${page.pageNumber}`);
                    }
                }
            }
            
            return orphans;
        }
        
        /**
         * Ajusta una p√°gina para prevenir hu√©rfanos
         */
        _adjustPageToPreventOrphans(page, nextPage, orphans) {
            let adjustedPage = JSON.parse(JSON.stringify(page)); // Deep copy
            let orphansFixed = 0;
            
            // Para cada hu√©rfano, intentar diferentes estrategias
            for (const orphan of orphans) {
                if (orphan.rule.forceBreakBefore) {
                    // Estrategia 1: Mover el header hu√©rfano a la siguiente p√°gina
                    const elementsToMove = adjustedPage.elements.splice(orphan.elementIndex);
                    
                    // Recalcular altura de p√°gina actual
                    adjustedPage.currentHeight = this._calculatePageHeight(adjustedPage.elements);
                    
                    // Reducir costo por eliminar hu√©rfano
                    adjustedPage.costScore = Math.max(0, adjustedPage.costScore - 50);
                    
                    orphansFixed++;
                    console.log(`üîÑ [FASE 3] Moviendo ${orphan.elementType} a siguiente p√°gina`);
                    
                    // Si hay p√°gina siguiente, agregar elementos all√≠
                    if (nextPage) {
                        nextPage.elements = elementsToMove.concat(nextPage.elements || []);
                        nextPage.currentHeight = this._calculatePageHeight(nextPage.elements);
                    }
                } else {
                    // Estrategia 2: Solo penalizar pero no mover
                    adjustedPage.costScore += orphan.rule.penaltyMultiplier * 20;
                }
            }
            
            return {
                page: adjustedPage,
                orphansFixed
            };
        }
        
        /**
         * Recalcula la distribuci√≥n completa despu√©s de ajustes
         */
        _recalculateDistribution(pages, measurements) {
            let totalCost = 0;
            const processedPages = [];
            
            for (const page of pages) {
                // Recalcular altura y costo
                page.currentHeight = this._calculatePageHeight(page.elements);
                totalCost += page.costScore;
                
                processedPages.push(page);
            }
            
            return {
                pages: processedPages,
                totalCost,
                avgCostPerPage: totalCost / pages.length
            };
        }
        
        /**
         * Calcula la altura total de elementos en una p√°gina
         */
        _calculatePageHeight(elements) {
            return elements.reduce((sum, el) => sum + (el.height || 0), 0);
        }
        
        /**
         * Detecta el tipo de elemento (reutiliza l√≥gica del OptimalBreakpointCalculator)
         */
        _detectElementType(element) {
            if (!element) return 'generic';
            
            const elementType = element.element ? element.element.toLowerCase() : '';
            const className = element.className ? element.className.toLowerCase() : '';
            
            if (elementType === 'h1' || elementType === 'h2' || className.includes('module-title')) {
                return 'module-header';
            }
            if (elementType === 'h3' || className.includes('section-title')) {
                return 'section-header';
            }
            if (className.includes('competency') || className.includes('card')) {
                return 'competency-card';
            }
            
            return 'generic';
        }
    }
    
    /**
     * CONTINUITY RULE ENGINE - FASE 3
     * Mantiene elementos relacionados juntos y mejora continuidad contextual
     */
    class ContinuityRuleEngine {
        constructor(pageHeight = 1122) {
            this.pageHeight = pageHeight;
            
            // Reglas de continuidad para diferentes tipos de elementos
            this.continuityRules = {
                'experience-items': {
                    maxGroupSize: 6,        // M√°ximo experiencias por grupo
                    minGroupSize: 2,        // M√≠nimo experiencias para formar grupo
                    keepWithHeader: true,   // Mantener con header de secci√≥n
                    allowSplit: false       // No dividir grupos entre p√°ginas
                },
                'education-items': {
                    maxGroupSize: 8,
                    minGroupSize: 3,
                    keepWithHeader: true,
                    allowSplit: false
                },
                'competency-cards': {
                    maxGroupSize: 4,        // M√°ximo 4 competencias por grupo
                    minGroupSize: 2,
                    keepWithHeader: true,
                    allowSplit: false       // Las tarjetas deben ir completas
                },
                'reference-items': {
                    maxGroupSize: 4,
                    minGroupSize: 2,
                    keepWithHeader: true,
                    allowSplit: true        // Referencias pueden dividirse
                },
                'editorial-paragraphs': {
                    maxGroupSize: 3,        // M√°ximo 3 p√°rrafos por grupo
                    minGroupSize: 1,
                    keepWithHeader: false,
                    allowSplit: true        // P√°rrafos pueden dividirse
                }
            };
            
            // Patrones de continuidad
            this.continuityPatterns = {
                'header-content': 0.8,     // Header debe tener 80% de su contenido
                'similar-elements': 0.6,   // Elementos similares juntos
                'module-coherence': 0.9    // Coherencia de m√≥dulo completo
            };
        }
        
        /**
         * Aplica reglas de continuidad a la distribuci√≥n
         */
        applyContinuityRules(distribution, measurements) {
            console.log('üîó [CONTINUITY] Aplicando reglas de continuidad...');
            
            try {
                // Identificar grupos de continuidad
                const continuityGroups = this._identifyContinuityGroups(measurements);
                console.log('üìã [CONTINUITY] Grupos identificados:', continuityGroups.length);
                
                // Aplicar reglas de agrupamiento
                const optimizedDistribution = this._applyGroupingRules(distribution, continuityGroups);
                
                // Verificar y ajustar coherencia de m√≥dulos
                const coherentDistribution = this._ensureModuleCoherence(optimizedDistribution, measurements);
                
                // Calcular m√©tricas de continuidad
                const continuityMetrics = this._calculateContinuityMetrics(coherentDistribution, continuityGroups);
                
                return {
                    ...coherentDistribution,
                    continuityGroups: continuityGroups.length,
                    groupsKeptTogether: continuityMetrics.groupsKeptTogether,
                    continuityScore: continuityMetrics.continuityScore,
                    splitGroups: continuityMetrics.splitGroups
                };
                
            } catch (error) {
                console.error('‚ùå [CONTINUITY] Error en aplicaci√≥n de reglas:', error);
                return {
                    ...distribution,
                    continuityGroups: 0,
                    groupsKeptTogether: 0,
                    continuityScore: 0,
                    error: error.message
                };
            }
        }
        
        /**
         * Identifica grupos de elementos que deben mantenerse juntos
         */
        _identifyContinuityGroups(measurements) {
            const groups = [];
            let currentGroup = null;
            
            measurements.forEach((element, index) => {
                const elementType = this._getElementType(element);
                const blockType = this._getBlockType(element);
                
                // Iniciar nuevo grupo si es header o cambio de tipo
                if (this._isGroupStarter(element, elementType)) {
                    if (currentGroup && currentGroup.elements.length > 0) {
                        groups.push(currentGroup);
                    }
                    
                    currentGroup = {
                        id: groups.length,
                        type: blockType,
                        elements: [element],
                        startIndex: index,
                        canSplit: this.continuityRules[blockType]?.allowSplit || false,
                        maxSize: this.continuityRules[blockType]?.maxGroupSize || 5
                    };
                }
                // A√±adir a grupo existente si es del mismo tipo
                else if (currentGroup && this._belongsToCurrentGroup(element, currentGroup)) {
                    currentGroup.elements.push(element);
                }
                // Crear grupo individual para elementos sin grupo
                else {
                    if (currentGroup && currentGroup.elements.length > 0) {
                        groups.push(currentGroup);
                    }
                    
                    currentGroup = {
                        id: groups.length,
                        type: blockType,
                        elements: [element],
                        startIndex: index,
                        canSplit: true,
                        maxSize: 1
                    };
                }
                
                // Cerrar grupo si alcanza tama√±o m√°ximo
                if (currentGroup && currentGroup.elements.length >= currentGroup.maxSize) {
                    groups.push(currentGroup);
                    currentGroup = null;
                }
            });
            
            // A√±adir √∫ltimo grupo si existe
            if (currentGroup && currentGroup.elements.length > 0) {
                groups.push(currentGroup);
            }
            
            console.log('üìä [CONTINUITY] Grupos formados:', groups.map(g => ({
                id: g.id,
                type: g.type,
                elements: g.elements.length,
                canSplit: g.canSplit
            })));
            
            return groups;
        }
        
        /**
         * Determina si un elemento inicia un nuevo grupo
         */
        _isGroupStarter(element, elementType) {
            return elementType.includes('header') || 
                   elementType.includes('module') || 
                   element.className?.includes('section-start');
        }
        
        /**
         * Determina si un elemento pertenece al grupo actual
         */
        _belongsToCurrentGroup(element, currentGroup) {
            const elementBlockType = this._getBlockType(element);
            const isSameType = elementBlockType === currentGroup.type;
            const hasSpace = currentGroup.elements.length < currentGroup.maxSize;
            
            return isSameType && hasSpace;
        }
        
        /**
         * Aplica reglas de agrupamiento a la distribuci√≥n
         */
        _applyGroupingRules(distribution, continuityGroups) {
            console.log('‚öôÔ∏è [CONTINUITY] Aplicando reglas de agrupamiento...');
            
            const newPages = [];
            let currentPage = { elements: [], currentHeight: 0, costScore: 0 };
            
            continuityGroups.forEach(group => {
                const groupHeight = group.elements.reduce((sum, el) => sum + (el.height || 0), 0);
                
                // Si el grupo no cabe en p√°gina actual y no se puede dividir
                if (!group.canSplit && (currentPage.currentHeight + groupHeight) > this.pageHeight && currentPage.elements.length > 0) {
                    newPages.push(currentPage);
                    currentPage = { elements: [], currentHeight: 0, costScore: 0 };
                }
                
                // Si el grupo se puede dividir y es muy grande
                if (group.canSplit && groupHeight > this.pageHeight * 0.8) {
                    const subGroups = this._splitGroup(group, currentPage);
                    subGroups.forEach(subGroup => {
                        subGroup.elements.forEach(element => {
                            if ((currentPage.currentHeight + element.height) > this.pageHeight && currentPage.elements.length > 0) {
                                newPages.push(currentPage);
                                currentPage = { elements: [], currentHeight: 0, costScore: 0 };
                            }
                            currentPage.elements.push(element);
                            currentPage.currentHeight += element.height || 0;
                        });
                    });
                } else {
                    // A√±adir grupo completo
                    group.elements.forEach(element => {
                        currentPage.elements.push(element);
                        currentPage.currentHeight += element.height || 0;
                    });
                }
                
                // Calcular costo de p√°gina
                currentPage.costScore = this._calculatePageCost(currentPage);
            });
            
            // A√±adir √∫ltima p√°gina
            if (currentPage.elements.length > 0) {
                newPages.push(currentPage);
            }
            
            return {
                pages: newPages,
                pageCount: newPages.length,
                totalCost: newPages.reduce((sum, page) => sum + page.costScore, 0)
            };
        }
        
        /**
         * Divide un grupo grande en subgrupos m√°s manejables
         */
        _splitGroup(group, currentPage) {
            const subGroups = [];
            const elementsPerSubGroup = Math.ceil(group.elements.length / 2);
            
            for (let i = 0; i < group.elements.length; i += elementsPerSubGroup) {
                subGroups.push({
                    elements: group.elements.slice(i, i + elementsPerSubGroup),
                    type: group.type + '-split',
                    canSplit: true
                });
            }
            
            console.log(`üîÑ [CONTINUITY] Grupo ${group.id} dividido en ${subGroups.length} subgrupos`);
            return subGroups;
        }
        
        /**
         * Asegura la coherencia de m√≥dulos completos
         */
        _ensureModuleCoherence(distribution, measurements) {
            console.log('üéØ [CONTINUITY] Asegurando coherencia de m√≥dulos...');
            
            // Identificar m√≥dulos y sus l√≠mites
            const modules = this._identifyModules(measurements);
            
            // Verificar que cada m√≥dulo tenga coherencia
            modules.forEach(module => {
                const moduleElements = measurements.slice(module.startIndex, module.endIndex + 1);
                const moduleHeight = moduleElements.reduce((sum, el) => sum + (el.height || 0), 0);
                
                // Si el m√≥dulo es peque√±o, mantenerlo junto
                if (moduleHeight < this.pageHeight * 0.6) {
                    this._keepModuleTogether(distribution, module, moduleElements);
                }
            });
            
            return distribution;
        }
        
        /**
         * Identifica m√≥dulos en las mediciones
         */
        _identifyModules(measurements) {
            const modules = [];
            let currentModule = null;
            
            measurements.forEach((element, index) => {
                const className = element.className?.toLowerCase() || '';
                
                if (className.includes('module') || className.includes('section-header')) {
                    if (currentModule) {
                        currentModule.endIndex = index - 1;
                        modules.push(currentModule);
                    }
                    
                    currentModule = {
                        name: className,
                        startIndex: index,
                        endIndex: index
                    };
                } else if (currentModule) {
                    currentModule.endIndex = index;
                }
            });
            
            if (currentModule) {
                modules.push(currentModule);
            }
            
            return modules;
        }
        
        /**
         * Mantiene un m√≥dulo completo junto en las p√°ginas
         */
        _keepModuleTogether(distribution, module, moduleElements) {
            // Implementaci√≥n simplificada - en producci√≥n ser√≠a m√°s compleja
            console.log(`üîó [CONTINUITY] Manteniendo m√≥dulo ${module.name} junto`);
        }
        
        /**
         * Calcula m√©tricas de continuidad
         */
        _calculateContinuityMetrics(distribution, continuityGroups) {
            let groupsKeptTogether = 0;
            let splitGroups = 0;
            
            continuityGroups.forEach(group => {
                if (this._isGroupKeptTogether(group, distribution)) {
                    groupsKeptTogether++;
                } else {
                    splitGroups++;
                }
            });
            
            const continuityScore = continuityGroups.length > 0 ? 
                groupsKeptTogether / continuityGroups.length : 1;
            
            return {
                groupsKeptTogether,
                splitGroups,
                continuityScore,
                totalGroups: continuityGroups.length
            };
        }
        
        /**
         * Verifica si un grupo se mantuvo junto
         */
        _isGroupKeptTogether(group, distribution) {
            // Simplificado: asume que grupos peque√±os se mantienen juntos
            return group.elements.length <= 3 || !group.canSplit;
        }
        
        /**
         * Calcula el costo de una p√°gina basado en continuidad
         */
        _calculatePageCost(page) {
            let cost = 0;
            
            // Penalizar p√°ginas con pocos elementos
            if (page.elements.length < 2) cost += 20;
            
            // Penalizar p√°ginas muy llenas
            const fillRatio = page.currentHeight / this.pageHeight;
            if (fillRatio > 0.9) cost += 15;
            if (fillRatio < 0.3) cost += 10;
            
            return cost;
        }
        
        /**
         * Obtiene el tipo de elemento
         */
        _getElementType(element) {
            return element.className?.toLowerCase() || 'unknown';
        }
        
        /**
         * Obtiene el tipo de bloque del elemento
         */
        _getBlockType(element) {
            const className = element.className?.toLowerCase() || '';
            
            if (className.includes('experience')) return 'experience-items';
            if (className.includes('education')) return 'education-items';
            if (className.includes('competency')) return 'competency-cards';
            if (className.includes('reference')) return 'reference-items';
            if (className.includes('editorial')) return 'editorial-paragraphs';
            
            return 'generic-content';
        }
    }
    
    // Exponer globalmente
    window.OptimalBreakpointCalculator = OptimalBreakpointCalculator;
    window.OrphanPreventionSystem = OrphanPreventionSystem;
    window.ContinuityRuleEngine = ContinuityRuleEngine;
    
})();

document.addEventListener('DOMContentLoaded', async function() {
    console.log('üöÄ [FASE 2] Inicializando sistema simplificado...');
    
    try {
        // Debug: Verificar estado de FASE 2
        console.log('üîç [FASE 2] Debug __layout:', {{{json __layout}}});
        
        // Verificar habilitaci√≥n real de FASE 2
        const fase2Enabled = {{#if __layout.fase2.enabled}}true{{else}}false{{/if}};
        const fase2Exists = {{#if __layout.fase2}}true{{else}}false{{/if}};
        
        console.log('üîç [FASE 2] Estado detallado:', { 
            fase2Exists, 
            fase2Enabled,
            metadata: {{#if __layout.fase2}}{{{json __layout.fase2}}}{{else}}null{{/if}}
        });
        
        // Ejecutar FASE 2 solo si est√° habilitada
        if (!fase2Enabled) {
            console.warn('‚ö†Ô∏è [FASE 2] FASE 2 no est√° habilitada. Verificar beforeRender en helpers.js');
            return;
        }
        
        console.log('‚úÖ [FASE 2] FASE 2 habilitada correctamente, ejecutando...');
        
        // Actualizar diagn√≥sticos en tiempo real
        const updateDiagnostics = (id, message, success = true) => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = `‚Ä¢ ${message}`;
                element.style.color = success ? '#28a745' : '#dc3545';
            }
        };
        
        // 1. Inicializar componentes simplificados FASE 2
        const cache = new window.SimpleMeasurementCache();
        const database = new window.SimpleMeasurementDatabase();
        const phantomRenderer = new window.SimplePhantomRenderer();
        
        updateDiagnostics('cache-status', 'Cache: ‚úÖ Cache simplificado inicializado');
        console.log('‚úÖ [FASE 2] Cache simplificado inicializado');
        
        // 2. Ejecutar medici√≥n y c√°lculo
        updateDiagnostics('phantom-status', 'PhantomRenderer: ‚è≥ Midiendo elementos...');
        updateDiagnostics('calculation-status', 'CalculationEngine: ‚è≥ Calculando distribuci√≥n...');
        
        try {
            // Medir elementos
            const measurements = await phantomRenderer.measureElements();
            
            // Calcular distribuci√≥n
            const distribution = phantomRenderer.calculateDistribution();
            
            updateDiagnostics('phantom-status', `PhantomRenderer: ‚úÖ ${measurements.length} elementos medidos`);
            updateDiagnostics('calculation-status', `CalculationEngine: ‚úÖ ${distribution.pageCount} p√°ginas estimadas`);
            
            console.log('‚úÖ [FASE 2] C√°lculo completado:', { measurements: measurements.length, pages: distribution.pageCount });
            
            // ================================================================================
            // üéØ EJECUTAR FASE 3 - DISTRIBUCI√ìN INTELIGENTE
            // ================================================================================
            try {
                console.log('üéØ [FASE 3] Iniciando distribuci√≥n inteligente...');
                
                // Validar datos de entrada
                console.log('üîç [FASE 3] Validando mediciones de FASE 2...');
                if (!measurements || measurements.length === 0) {
                    throw new Error('No hay mediciones disponibles de FASE 2');
                }
                
                console.log('üîç [FASE 3] Primera medici√≥n:', JSON.stringify(measurements[0], null, 2));
                console.log('üîç [FASE 3] √öltima medici√≥n:', JSON.stringify(measurements[measurements.length - 1], null, 2));
                
                // Inicializar calculadora de puntos de corte
                const breakpointCalculator = new window.OptimalBreakpointCalculator();
                
                // Calcular distribuci√≥n √≥ptima basada en mediciones reales
                const totalHeight = measurements.reduce((sum, m) => sum + (m.height || 0), 0);
                console.log('üîç [FASE 3] Altura total calculada:', totalHeight);
                
                const optimalDistribution = breakpointCalculator.calculateOptimalBreaks(measurements, totalHeight);
                
                // ================================================================================
                // üõ°Ô∏è APLICAR ORPHAN PREVENTION SYSTEM
                // ================================================================================
                console.log('üõ°Ô∏è [FASE 3] Inicializando OrphanPreventionSystem...');
                
                const orphanPrevention = new window.OrphanPreventionSystem();
                const finalDistribution = orphanPrevention.preventOrphans(optimalDistribution, measurements);
                
                console.log('‚úÖ [FASE 3] OrphanPrevention completado:', {
                    orphansDetected: finalDistribution.orphansDetected,
                    orphansFixed: finalDistribution.orphansFixed,
                    improvementScore: (finalDistribution.improvementScore * 100).toFixed(1) + '%',
                    newTotalCost: finalDistribution.totalCost
                });
                
                // ================================================================================
                // üîó CONTINUITY RULE ENGINE - FASE 3 (COMPONENTE 3/3)
                // ================================================================================
                console.log('üîó [FASE 3] Iniciando ContinuityRuleEngine...');
                
                const continuityEngine = new window.ContinuityRuleEngine(1122); // A4 height in px
                const finalDistributionWithContinuity = continuityEngine.applyContinuityRules(finalDistribution, measurements);
                
                console.log('‚úÖ [FASE 3] ContinuityRuleEngine completado:', {
                    continuityGroups: finalDistributionWithContinuity.continuityGroups,
                    groupsKeptTogether: finalDistributionWithContinuity.groupsKeptTogether,
                    continuityScore: (finalDistributionWithContinuity.continuityScore * 100).toFixed(1) + '%',
                    totalCost: finalDistributionWithContinuity.totalCost
                });
                
                // Almacenar resultados finales en cache para futuras fases
                cache.set('fase3_distribution', {
                    finalPages: finalDistributionWithContinuity.pages,
                    originalPages: optimalDistribution.pages,
                    totalCost: finalDistributionWithContinuity.totalCost,
                    avgCostPerPage: finalDistributionWithContinuity.totalCost / finalDistributionWithContinuity.pages.length,
                    optimization: optimalDistribution.optimization,
                    orphanPrevention: {
                        detected: finalDistribution.orphansDetected,
                        fixed: finalDistribution.orphansFixed,
                        improvementScore: finalDistribution.improvementScore
                    },
                    continuityRules: {
                        groups: finalDistributionWithContinuity.continuityGroups,
                        keptTogether: finalDistributionWithContinuity.groupsKeptTogether,
                        continuityScore: finalDistributionWithContinuity.continuityScore
                    },
                    timestamp: Date.now()
                });
                
                // ================================================================================
                // üìÑ APLICAR DISTRIBUCI√ìN AL HTML FINAL - FASE 3
                // ================================================================================
                console.log('üìÑ [FASE 3] Aplicando distribuci√≥n inteligente al HTML...');
                
                // Declarar variable fuera del try-catch para disponibilidad global
                let spaceOptimization = {
                    optimizationsApplied: 0,
                    totalSpaceSaved: 0,
                    optimizations: [],
                    efficiency: 0
                };
                
                try {
                    // Almacenar distribuci√≥n globalmente para acceso desde CSS
                    window.FASE3_DISTRIBUTION = finalDistributionWithContinuity;
                    
                    // ================================================================================
                    // üìè OPTIMIZACI√ìN DE ESPACIO EN BLANCO - NUEVA FUNCIONALIDAD
                    // ================================================================================
                    console.log('üìè [FASE 3] Iniciando optimizaci√≥n de espacio en blanco...');
                    
                    // Esperar a que el DOM est√© completamente renderizado
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Analizar y optimizar espacio disponible
                    spaceOptimization = await optimizePageSpace(measurements);
                    
                    console.log('‚úÖ [FASE 3] Optimizaci√≥n de espacio completada:', spaceOptimization);
                    
                    // Generar CSS din√°mico mejorado con optimizaci√≥n de espacio
                    const intelligentCSS = generateSpaceOptimizedCSS(finalDistributionWithContinuity, measurements, spaceOptimization);
                    
                    // Inyectar CSS inteligente
                    let styleElement = document.getElementById('fase3-intelligent-breaks');
                    if (!styleElement) {
                        styleElement = document.createElement('style');
                        styleElement.id = 'fase3-intelligent-breaks';
                        styleElement.innerHTML = intelligentCSS;
                        document.head.appendChild(styleElement);
                        console.log('üìè [SPACE] CSS inyectado en DOM:', intelligentCSS.substring(0, 500) + '...');
                    }
                    
                    // Aplicar atributos din√°micos para CSS targeting
                    applyIntelligentBreakAttributes(finalDistributionWithContinuity, measurements);
                    
                    // FUERZA ESPEC√çFICA: Verificar y aplicar CSS para "Datos Destacados"
                    const datosDestacadosSection = document.querySelector('.module-0 .section-title');
                    if (datosDestacadosSection) {
                        console.log('üìè [SPACE] Encontrada secci√≥n "Datos Destacados", aplicando CSS espec√≠fico...');
                        
                        // Aplicar CSS directamente en el elemento si es necesario
                        const textoEditorial = datosDestacadosSection.nextElementSibling;
                        if (textoEditorial && textoEditorial.classList.contains('texto-editorial')) {
                            textoEditorial.style.pageBreakBefore = 'auto';
                            textoEditorial.style.breakBefore = 'auto';
                            textoEditorial.style.marginTop = '0px';
                            console.log('üìè [SPACE] CSS aplicado directamente a texto-editorial');
                        }
                    }
                    
                    console.log('‚úÖ [FASE 3] CSS inteligente con optimizaci√≥n de espacio aplicado');
                    
                } catch (error) {
                    console.error('‚ùå [FASE 3] Error aplicando distribuci√≥n al HTML:', error);
                }
                
                // Recalcular m√©tricas con la distribuci√≥n final
                const finalEfficiency = calculateFinalEfficiency(finalDistributionWithContinuity, optimalDistribution);
                
                console.log('‚úÖ [FASE 3] Distribuci√≥n inteligente COMPLETADA:', {
                    pages: finalDistributionWithContinuity.pages.length,
                    avgCost: (finalDistributionWithContinuity.totalCost / finalDistributionWithContinuity.pages.length).toFixed(1),
                    efficiency: finalEfficiency.toFixed(1) + '%',
                    orphanHeaders: finalDistribution.orphansDetected,
                    orphansFixed: finalDistribution.orphansFixed,
                    continuityGroups: finalDistributionWithContinuity.continuityGroups,
                    groupsKeptTogether: finalDistributionWithContinuity.groupsKeptTogether,
                    continuityScore: (finalDistributionWithContinuity.continuityScore * 100).toFixed(1) + '%',
                    naturalBreaks: optimalDistribution.optimization.naturalBreaks,
                    forcedBreaks: optimalDistribution.optimization.forcedBreaks
                });
                
                // Test de validaci√≥n de resultados
                console.log('üß™ [FASE 3] Ejecutando tests de validaci√≥n...');
                runValidationTests(finalDistributionWithContinuity, measurements);
                
                // Actualizar diagn√≥sticos
                updateDiagnostics('breakpoint-status', `OptimalBreakpoint: ‚úÖ ${finalDistributionWithContinuity.pages.length} p√°ginas optimizadas`);
                updateDiagnostics('orphan-status', `OrphanPrevention: ‚úÖ ${finalDistribution.orphansFixed}/${finalDistribution.orphansDetected} hu√©rfanos corregidos`);
                updateDiagnostics('continuity-status', `ContinuityRules: ‚úÖ ${finalDistributionWithContinuity.groupsKeptTogether}/${finalDistributionWithContinuity.continuityGroups} grupos unidos`);
                updateDiagnostics('html-application-status', `HTML Application: ‚úÖ Page breaks + Optimizaci√≥n de espacio aplicados`);
                updateDiagnostics('space-optimization-status', `Space Optimization: ‚úÖ ${spaceOptimization.optimizationsApplied} optimizaciones aplicadas`);
                updateDiagnostics('optimization-status', `Optimizaci√≥n: ‚úÖ ${finalEfficiency.toFixed(1)}% eficiencia`);
                
            } catch (error) {
                console.error('‚ùå [FASE 3] Error en distribuci√≥n inteligente:', error.message || error.toString() || error);
                console.error('‚ùå [FASE 3] Stack trace:', error.stack);
                updateDiagnostics('breakpoint-status', `OptimalBreakpoint: ‚ùå ${error.message || 'Error desconocido'}`, false);
                updateDiagnostics('orphan-status', 'OrphanPrevention: ‚ùå Error en prevenci√≥n', false);
                updateDiagnostics('continuity-status', 'ContinuityRules: ‚ùå Error en continuidad', false);
                updateDiagnostics('html-application-status', 'HTML Application: ‚ùå Error aplicando al DOM', false);
                updateDiagnostics('space-optimization-status', 'Space Optimization: ‚ùå Error en optimizaci√≥n', false);
                updateDiagnostics('optimization-status', 'Optimizaci√≥n: ‚ùå Error en optimizaci√≥n', false);
            }
            
            // Mostrar estad√≠sticas
            const cacheStats = cache.getStats();
            console.log('üìä [FASE 2] Estad√≠sticas cache:', cacheStats);
            
        } catch (error) {
            updateDiagnostics('phantom-status', 'PhantomRenderer: ‚ùå Error en medici√≥n', false);
            updateDiagnostics('calculation-status', 'CalculationEngine: ‚ùå Error en c√°lculo', false);
            console.error('‚ùå [FASE 2] Error en c√°lculo:', error);
        }
        
        // Continuar con la ejecuci√≥n independientemente del estado
        
    } catch (error) {
        console.error('‚ùå [FASE 2] Error cr√≠tico:', error);
    }
    
    // ================================================================================
    // üß™ FUNCI√ìN DE TESTING PARA FASE 3
    // ================================================================================
    function runValidationTests(optimalDistribution, measurements) {
        try {
            // Test 1: Verificar que no se perdieron elementos
            const totalElementsIn = measurements.length;
            const totalElementsOut = optimalDistribution.pages.reduce((sum, page) => sum + page.elements.length, 0);
            
            if (totalElementsIn === totalElementsOut) {
                console.log('‚úÖ [TEST] Integridad de elementos: OK (' + totalElementsIn + ' elementos)');
            } else {
                console.error('‚ùå [TEST] Integridad de elementos: FALLO (' + totalElementsIn + ' in, ' + totalElementsOut + ' out)');
            }
            
            // Test 2: Verificar que no hay p√°ginas vac√≠as
            const emptyPages = optimalDistribution.pages.filter(page => page.elements.length === 0);
            if (emptyPages.length === 0) {
                console.log('‚úÖ [TEST] P√°ginas vac√≠as: OK (sin p√°ginas vac√≠as)');
            } else {
                console.error('‚ùå [TEST] P√°ginas vac√≠as: FALLO (' + emptyPages.length + ' p√°ginas vac√≠as)');
            }
            
            // Test 3: Verificar distribuci√≥n de costos
            const highCostPages = optimalDistribution.pages.filter(page => page.costScore > 80);
            if (highCostPages.length <= optimalDistribution.pageCount * 0.2) {
                console.log('‚úÖ [TEST] Distribuci√≥n de costos: OK (<20% p√°ginas con costo alto)');
            } else {
                console.warn('‚ö†Ô∏è [TEST] Distribuci√≥n de costos: ' + highCostPages.length + ' p√°ginas con costo alto');
            }
            
            // Test 4: Verificar eficiencia general
            const efficiency = optimalDistribution.optimization && 
                              typeof optimalDistribution.optimization.efficiency === 'string' ? 
                              parseFloat(optimalDistribution.optimization.efficiency) : 60;
            if (efficiency >= 50) {
                console.log('‚úÖ [TEST] Eficiencia: OK (' + efficiency + '%)');
            } else {
                console.warn('‚ö†Ô∏è [TEST] Eficiencia: Baja (' + efficiency + '%)');
            }
            
        } catch (error) {
            console.error('‚ùå [TEST] Error en validaci√≥n:', error);
        }
    }
    
    /**
     * OPTIMIZACI√ìN DE ESPACIO EN BLANCO - Mide y aprovecha espacio disponible
     */
    async function optimizePageSpace(measurements) {
        console.log('üìè [SPACE] Analizando espacio disponible...');
        
        const pageHeight = 1122; // A4 height in px
        const optimizations = [];
        
        // Obtener todos los m√≥dulos y secciones del DOM
        const modules = document.querySelectorAll('.module');
        const sections = document.querySelectorAll('.section');
        
        let totalSpaceSaved = 0;
        let optimizationsApplied = 0;
        
        // Analizar cada m√≥dulo para ver si puede aprovechar mejor el espacio
        modules.forEach((module, moduleIndex) => {
            try {
                const moduleRect = module.getBoundingClientRect();
                const moduleBottom = moduleRect.bottom;
                
                // Calcular espacio disponible hasta el final de p√°gina estimada
                const currentPageBottom = Math.ceil(moduleBottom / pageHeight) * pageHeight;
                const availableSpace = currentPageBottom - moduleBottom;
                
                console.log(`üìè [SPACE] M√≥dulo ${moduleIndex}: ${availableSpace.toFixed(0)}px disponibles`);
                
                if (availableSpace > 100) { // Si hay m√°s de 100px disponibles
                    
                    // Buscar siguiente m√≥dulo o secci√≥n que pueda comenzar aqu√≠
                    const nextModule = modules[moduleIndex + 1];
                    if (nextModule) {
                        
                        const nextSections = nextModule.querySelectorAll('.section');
                        if (nextSections.length > 0) {
                            const firstSection = nextSections[0];
                            
                            // Verificar si header + primer elemento caben en el espacio disponible
                            const canStartHere = checkIfCanStartInAvailableSpace(firstSection, availableSpace);
                            
                            if (canStartHere.fits) {
                                optimizations.push({
                                    type: 'start-section-early',
                                    currentModule: moduleIndex,
                                    nextModule: moduleIndex + 1,
                                    availableSpace: availableSpace,
                                    sectionsThatFit: canStartHere.elementsThatFit,
                                    spaceSaved: canStartHere.spaceSaved
                                });
                                
                                totalSpaceSaved += canStartHere.spaceSaved;
                                optimizationsApplied++;
                                
                                console.log(`‚úÖ [SPACE] Optimizaci√≥n posible: M√≥dulo ${moduleIndex + 1} puede empezar ${canStartHere.spaceSaved}px antes`);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.warn(`‚ö†Ô∏è [SPACE] Error analizando m√≥dulo ${moduleIndex}:`, error);
            }
        });
        
        return {
            optimizationsApplied,
            totalSpaceSaved,
            optimizations,
            efficiency: optimizationsApplied > 0 ? (totalSpaceSaved / (pageHeight * modules.length)) * 100 : 0
        };
    }
    
    /**
     * Verifica si una secci√≥n puede empezar en el espacio disponible
     */
    function checkIfCanStartInAvailableSpace(section, availableSpace) {
        try {
            // Obtener elementos de la secci√≥n
            const sectionTitle = section.querySelector('.section-title');
            const items = section.querySelectorAll('.bloque-editorial, .lista-item, .experiencia-item, .paragraph');
            
            let totalHeight = 0;
            let elementsThatFit = 0;
            
            // Altura del t√≠tulo
            if (sectionTitle) {
                totalHeight += 40; // Estimaci√≥n para title + margin
            }
            
            // Verificar cu√°ntos elementos caben
            for (let i = 0; i < items.length && totalHeight < availableSpace; i++) {
                const estimatedItemHeight = getEstimatedElementHeight(items[i]);
                
                if (totalHeight + estimatedItemHeight <= availableSpace) {
                    totalHeight += estimatedItemHeight;
                    elementsThatFit++;
                } else {
                    break;
                }
            }
            
            // Requiere al menos t√≠tulo + 1 elemento para considerarlo viable
            const fits = elementsThatFit >= 1 && totalHeight <= availableSpace;
            
            return {
                fits,
                elementsThatFit,
                totalHeightNeeded: totalHeight,
                spaceSaved: fits ? (availableSpace - 50) : 0 // Conservar 50px de margen
            };
            
        } catch (error) {
            console.warn('‚ö†Ô∏è [SPACE] Error en checkIfCanStartInAvailableSpace:', error);
            return { fits: false, elementsThatFit: 0, spaceSaved: 0 };
        }
    }
    
    /**
     * Estima la altura de un elemento bas√°ndose en su tipo
     */
    function getEstimatedElementHeight(element) {
        const className = element.className || '';
        
        if (className.includes('bloque-editorial')) return 120;
        if (className.includes('experiencia-item')) return 100;
        if (className.includes('lista-item')) return 60;
        if (className.includes('paragraph')) return 50;
        if (className.includes('competency-card')) return 150;
        
        // Fallback: intentar medir altura real
        try {
            const rect = element.getBoundingClientRect();
            return rect.height || 80;
        } catch {
            return 80; // Altura por defecto
        }
    }
    
    /**
     * Genera CSS optimizado para aprovechar espacio en blanco
     */
    function generateSpaceOptimizedCSS(distribution, measurements, spaceOptimization) {
        let css = '/* üìè FASE 3 - CSS Optimizaci√≥n de Espacio AGRESIVO */\n\n';
        
        // CSS FUERZA FLUJO NATURAL - Sobreescribir cualquier CSS restrictivo
        css += `
        /* FORZAR FLUJO NATURAL - Sobreescribir reglas restrictivas */
        .module {
            page-break-before: auto !important;
            break-before: auto !important;
            page-break-inside: auto !important;
            break-inside: auto !important;
        }
        
        .section {
            page-break-before: auto !important;
            break-before: auto !important;
            page-break-inside: auto !important;
            break-inside: auto !important;
        }
        
        .module-title {
            page-break-before: auto !important;
            break-before: auto !important;
            page-break-after: avoid !important;
            break-after: avoid !important;
            orphans: 1 !important;
            widows: 1 !important;
        }
        
        .section-title {
            page-break-before: auto !important;
            break-before: auto !important;
            page-break-after: avoid !important;
            break-after: avoid !important;
            orphans: 1 !important;
            widows: 1 !important;
        }
        
        /* ELEMENTOS QUE NO DEBEN CORTARSE INTERNAMENTE */
        .bloque-editorial, .experiencia-item, .lista-item, .competency-card {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
        }
        
        /* FUERZA ESPEC√çFICA: Datos Destacados deben aparecer inmediatamente despu√©s */
        .module-0 .section-title:contains("Datos Destacados") + .texto-editorial {
            page-break-before: auto !important;
            break-before: auto !important;
        }
        
        /* FUERZA: Permitir que el primer item editorial se pegue al header */
        .texto-editorial .bloque-editorial:first-child {
            page-break-before: auto !important;
            break-before: auto !important;
        }
        
        `;
        
        // Aplicar optimizaciones espec√≠ficas basadas en el an√°lisis de espacio
        spaceOptimization.optimizations.forEach((opt, index) => {
            if (opt.type === 'start-section-early') {
                css += `
        /* OPTIMIZACI√ìN ${index + 1}: FORZAR M√≥dulo ${opt.nextModule} a empezar antes */
        .module-${opt.nextModule} {
            page-break-before: auto !important;
            break-before: auto !important;
            margin-top: 0px !important;
        }
        
        .module-${opt.nextModule} .module-header {
            page-break-before: auto !important;
            break-before: auto !important;
            margin-top: 0px !important;
        }
        
        /* Asegurar que elementos fluyan juntos */
        .module-${opt.nextModule} .section:first-child .lista-item:nth-child(-n+${opt.sectionsThatFit}),
        .module-${opt.nextModule} .section:first-child .bloque-editorial:nth-child(-n+${opt.sectionsThatFit}) {
            page-break-after: avoid !important;
            break-after: avoid !important;
        }
        `;
            }
        });
        
        // CSS espec√≠fico solo para casos que realmente requieren page break
        css += `
        
        /* BREAKS ESPEC√çFICOS - Solo cuando sea absolutamente necesario */
        
        /* Conclusiones siempre en p√°gina nueva */
        .module[data-breadcrumb="Conclusiones"] {
            page-break-before: always !important;
            break-before: page !important;
        }
        
        `;
        
        console.log(`üìè [SPACE] CSS AGRESIVO generado con ${spaceOptimization.optimizationsApplied} optimizaciones de espacio`);
        
        return css;
    }
    
    /**
     * Genera CSS inteligente SELECTIVO basado en distribuci√≥n FASE 3
     */
    function generateIntelligentPageBreaksCSS(distribution, measurements) {
        let css = '/* üß† FASE 3 - CSS Selectivo de Distribuci√≥n */\n\n';
        
        // REGLAS M√çNIMAS - Solo lo esencial para evitar cortes problem√°ticos
        css += `
        /* SOLO elementos cr√≠ticos que no deben cortarse */
        .bloque-editorial, .experiencia-item, .lista-item, .competency-card {
            page-break-inside: avoid;
            break-inside: avoid;
        }
        
        /* Headers solo evitar corte despu√©s (no forzar p√°gina nueva) */
        .module-title, .section-title, .editorial-subtitulo {
            page-break-after: avoid;
            break-after: avoid;
        }
        
        `;
        
        // SOLO aplicar breaks espec√≠ficos calculados por FASE 3 cuando realmente sean necesarios
        let significantBreaks = 0;
        
        distribution.pages.forEach((page, pageIndex) => {
            if (pageIndex === 0 || pageIndex === 1) return; // No breaks en primeras 2 p√°ginas
            
            if (page.elements && page.elements.length > 0) {
                const firstElement = page.elements[0];
                
                // SOLO aplicar break si es realmente significativo (costo alto)
                const pageCost = page.costScore || 0;
                if (pageCost > 50 || firstElement.element === 'section') { // Solo breaks importantes
                    
                    if (firstElement.className && firstElement.className.includes('module')) {
                        css += `
        /* BREAK CALCULADO: P√°gina ${pageIndex + 1} - M√≥dulo nuevo */
        .${firstElement.className.split(' ')[0]}[data-fase3-break-page="${pageIndex + 1}"] {
            page-break-before: always;
            break-before: page;
        }
        `;
                        significantBreaks++;
                    }
                }
            }
        });
        
        // REGLAS ESPEC√çFICAS SOLO para casos problem√°ticos
        css += `
        
        /* REGLAS ESPEC√çFICAS - Solo cuando necesario */
        
        /* Conclusiones siempre en p√°gina nueva */
        .module-3 {
            page-break-before: always;
            break-before: page;
        }
        
        /* Competencias mantener juntas cuando sea posible */
        .module-2 .competency-card {
            page-break-inside: avoid;
            break-inside: avoid;
        }
        
        /* Reducir espaciado excesivo */
        .module-title {
            margin-top: 15px;
            margin-bottom: 10px;
        }
        
        `;
        
        console.log(`üìÑ [FASE 3] CSS generado con ${significantBreaks} breaks significativos de ${distribution.pages.length} p√°ginas`);
        
        return css;
    }
    
    /**
     * Aplica atributos selectivos solo para breaks significativos
     */
    function applyIntelligentBreakAttributes(distribution, measurements) {
        console.log('üéØ [FASE 3] Aplicando atributos SELECTIVOS...');
        
        let significantAttributesApplied = 0;
        
        // Encontrar m√≥dulos
        const modules = document.querySelectorAll('.module');
        
        distribution.pages.forEach((page, pageIndex) => {
            if (pageIndex <= 1) return; // No atributos en primeras p√°ginas
            
            if (page.elements && page.elements.length > 0) {
                const firstElement = page.elements[0];
                const pageCost = page.costScore || 0;
                
                // SOLO aplicar atributos si el break es significativo
                if (pageCost > 50 || firstElement.element === 'section') {
                    
                    // Buscar m√≥dulo espec√≠fico
                    modules.forEach((module, moduleIndex) => {
                        if (firstElement.className && module.classList.contains(firstElement.className.split(' ')[0])) {
                            module.setAttribute('data-fase3-break-page', pageIndex + 1);
                            module.setAttribute('data-fase3-cost', pageCost);
                            significantAttributesApplied++;
                            
                            console.log(`üéØ [FASE 3] Atributo significativo: ${module.className} -> P√°gina ${pageIndex + 1} (Costo: ${pageCost})`);
                        }
                    });
                }
            }
        });
        
        // NO aplicar atributos a todos los headers - solo los cr√≠ticos
        const criticalHeaders = document.querySelectorAll('.module-title');
        criticalHeaders.forEach((header, index) => {
            if (index >= 2) { // Solo m√≥dulos 3+
                header.setAttribute('data-fase3-critical', 'true');
            }
        });
        
        console.log(`‚úÖ [FASE 3] ${significantAttributesApplied} atributos SELECTIVOS aplicados`);
        
        return significantAttributesApplied;
    }
    
    // Funci√≥n para calcular eficiencia final
    function calculateFinalEfficiency(finalDistribution, originalDistribution) {
        try {
            const originalCost = originalDistribution.totalCost;
            const finalCost = finalDistribution.totalCost;
            const orphansFixed = finalDistribution.orphansFixed || 0;
            const orphansDetected = finalDistribution.orphansDetected || 1;
            
            // Mejora por reducci√≥n de costo
            const costImprovement = Math.max(0, (originalCost - finalCost) / originalCost);
            
            // Mejora por correcci√≥n de hu√©rfanos
            const orphanImprovement = orphansFixed / orphansDetected;
            
            // Eficiencia combinada
            const baseEfficiency = parseFloat(originalDistribution.optimization.efficiency) || 50;
            const improvement = (costImprovement + orphanImprovement) * 25; // Hasta 50% mejora adicional
            
            return Math.min(95, baseEfficiency + improvement);
        } catch (error) {
            console.warn('‚ö†Ô∏è [FASE 3] Error calculando eficiencia final:', error);
            return 60; // Eficiencia por defecto
        }
    }
    
    // Se√±alar que JSReport puede continuar
    setTimeout(() => {
        window.JSREPORT_READY_TO_START = true;
        console.log('üèÅ [FASE 2+3] JSReport ready signal enviado');
    }, 500);
});
</script>
</body>
</html>
